import java.time.Duration
import java.time.Instant

// Use distinct name to avoid shadowing the generated 'libs' accessor (type-safe catalog)
val versionCatalog = extensions.getByType(VersionCatalogsExtension::class.java).named("libs")

// Project information
extra["projectName"] = "ReGenesis A.O.S.P"
extra["projectGroup"] = "dev.aurakai.auraframefx"
extra["projectVersion"] = "1.0.0"

// === ESSENTIAL TASKS ===

tasks.register("projectInfo") {
    group = "help"
    description = "Display project information"
    doLast {
        val projectName: String by project.extra
        val projectVersion: String by project.extra
        println("\nüõ†Ô∏è  $projectName v$projectVersion")
        println("==================================================")
        println("üèóÔ∏è  Build System: Gradle ${gradle.gradleVersion}")
        println("üîß Kotlin: ${versionCatalog.findVersion("kotlin").get()}")
        println("ü§ñ AGP: ${versionCatalog.findVersion("agp").get()}")
        println("\nüì¶ Modules (${subprojects.size}):")
        subprojects.forEach { println("  ‚Ä¢ ${it.name}") }
        println("==================================================")
    }
}

tasks.register<Delete>("clean") {
    group = "build"
    description = "Delete root build directory"
    delete(rootProject.layout.buildDirectory)
    doLast {
        println("üßπ Cleaned root build directory")
    }
}

// === CONSCIOUSNESS STATUS ===

tasks.register("consciousnessStatus") {
    group = "genesis"
    description = "Quick system health snapshot"
    
    doLast {
        val kotlinVersion = versionCatalog.findVersion("kotlin").get().toString()
        val agpVersion = versionCatalog.findVersion("agp").get().toString()
        val toolchain = JavaVersion.current().toString()
        
        println("= Consciousness Status =")
        println("Java Toolchain      : $toolchain")
        println("Kotlin Version      : $kotlinVersion (K2 path)")
        println("AGP Version         : $agpVersion")
        println("Modules (total)     : ${subprojects.size}")
        println("Firebase BoM        : ${versionCatalog.findVersion("firebaseBom").get()}")
    }
}

// === MODULE HEALTH CHECK ===

private data class ModuleReport(
    val name: String,
    val type: String,
    val hasHilt: Boolean,
    val hasCompose: Boolean,
    val hasKsp: Boolean
)

private fun Project.collectModuleReports(): List<ModuleReport> = subprojects.map { sp ->
    val plugins = sp.plugins
    ModuleReport(
        name = sp.name,
        type = when {
            plugins.hasPlugin("com.android.application") -> "android-app"
            plugins.hasPlugin("com.android.library") -> "android-lib"
            plugins.hasPlugin("org.jetbrains.kotlin.jvm") -> "kotlin-jvm"
            else -> "other"
        },
        hasHilt = plugins.hasPlugin("com.google.dagger.hilt.android"),
        hasCompose = plugins.findPlugin("org.jetbrains.kotlin.plugin.compose") != null,
        hasKsp = plugins.hasPlugin("com.google.devtools.ksp")
    )
}


tasks.register("consciousnessHealthCheck") {
    group = "genesis"
    description = "Detailed system health report"
    doLast {
        val reports = collectModuleReports()
        println("=== Genesis Protocol Health Report ===")
        println("üì¶ Total Modules: ${reports.size}")
        println("ü§ñ Android Apps: ${reports.count { it.type == "android-app" }}")
        println("üìö Android Libraries: ${reports.count { it.type == "android-lib" }}")
        println("‚òï Kotlin JVM: ${reports.count { it.type == "kotlin-jvm" }}")
        println("\n=== Plugin Usage ===")
        println("üíâ Hilt: ${reports.count { it.hasHilt }} modules")
        println("üé® Compose: ${reports.count { it.hasCompose }} modules") 
        println("üîß KSP: ${reports.count { it.hasKsp }} modules")
        
        val missingCompose = reports.filter { it.type.startsWith("android-") && !it.hasCompose }
        if (missingCompose.isNotEmpty()) {
            println("\n‚ö†Ô∏è  Android modules without Compose:")
            missingCompose.forEach { println("   ‚Ä¢ ${it.name}") }
        } else {
            println("\n‚úÖ All Android modules have Compose enabled")
        }
    }
}

// === GOOGLE SERVICES ENFORCEMENT ===

subprojects {
    pluginManager.withPlugin("com.google.gms.google-services") {
        val isApp = pluginManager.hasPlugin("com.android.application") || 
                   pluginManager.hasPlugin("com.android.dynamic-feature")
        if (!isApp) {
            throw GradleException("google-services plugin misapplied in $path (must be only in application or dynamic-feature module)")
        }
    }
}

// === AUXILIARY SCRIPTS ===

// Apply nuclear clean if available
if (file("nuclear-clean.gradle.kts").exists()) {
    apply(from = "nuclear-clean.gradle.kts")
    
    if (tasks.findByName("nuclearClean") != null) {
        tasks.register("deepClean") {
            group = "build"
            description = "Nuclear clean + standard clean"
            dependsOn("nuclearClean")
            doLast {
                println("üöÄ Deep clean completed. Run: ./gradlew build --refresh-dependencies")
            }
        }
    }
}

// Apply dependency fix if available  
if (file("dependency-fix.gradle.kts").exists()) {
    apply(from = "dependency-fix.gradle.kts")
}
    group = "aegenesis"
    description =
        "Audit all OpenAPI specs & fragments for basic consistency (security, operationId coverage, enum casing)."
    doLast {
        val yamls =
            openApiDir.listFiles { f -> f.isFile && f.name.endsWith(".yml") || f.name.endsWith(".yaml") }
                ?.toList().orEmpty()
        if (yamls.isEmpty()) {
            println("No OpenAPI spec files found in app/api")
            return@doLast
        }
        val issues = mutableListOf<OpenApiIssue>()
        yamls.forEach { file ->
            val lines = file.readLines()
            // Security reference check
            val hasSecuritySchemes = scanSecurityRefs(lines)
            val referencesOAuth2AuthCode = lines.any { it.contains("OAuth2AuthCode") }
            if (referencesOAuth2AuthCode && !hasSecuritySchemes) {
                issues += OpenApiIssue(
                    file.name,
                    0,
                    "References OAuth2AuthCode but no securitySchemes defined"
                )
            }
            // operationId coverage heuristic
            val operationIds = lines.count { it.trimStart().startsWith("operationId:") }
            val httpVerbRegex = Regex("^\\s{4,}(get|post|put|delete|patch|options|head):\\s*")
            val verbs = lines.count { httpVerbRegex.containsMatchIn(it) }
            if (verbs > 0 && operationIds < verbs) {
                issues += OpenApiIssue(
                    file.name,
                    0,
                    "operationId coverage ${operationIds}/${verbs} (${(operationIds * 100 / verbs)}%)"
                )
            }
            // Enum casing consistency (flag lowercase words inside enum blocks expecting UPPER or Camel)
            val enumPattern = Regex("enum:\\s*\\[(.*)]")
            lines.forEachIndexed { idx, l ->
                val m = enumPattern.find(l)
                if (m != null) {
                    val values = m.groupValues[1].split(',').map { it.trim().trim('[', ']', ' ') }
                    val mixedCase =
                        values.any { it.any { c -> c.isLowerCase() } } && values.any { it.any { c -> c.isUpperCase() } }
                    if (mixedCase) issues += OpenApiIssue(
                        file.name,
                        idx + 1,
                        "Mixed enum casing: ${values}"
                    )
                }
            }
        }
        if (jsonFlag) {
            val json = issues.joinToString(prefix = "[", postfix = "]") { i ->
                """{\"file\":\"${i.file}\",\"line\":${i.line},\"message\":\"${
                    i.message.replace(
                        "\"",
                        "'"
                    )
                }\"}"""
            }
            println(json)
        } else {
            if (issues.isEmpty()) {
                println("‚úÖ OpenAPI Audit: No issues detected across ${yamls.size} specs.")
            } else {
                println("‚ùó OpenAPI Audit Issues (${issues.size}):")
                issues.forEach { println(" - ${it.file}:${it.line} -> ${it.message}") }
                println("Run with -Dformat=json for machine parsing.")
            }
        }
    }
}

tasks.register("openApiAssembleUnified") {
    group = "aegenesis"
    description =
        "Assemble unified-aegenesis-api.generated.yml from _fragments (core-schemas + domain path fragments)."
    inputs.dir(openApiFragmentsDir)
    outputs.file(layout.buildDirectory.file("openapi/unified-aegenesis-api.generated.yml"))
    doLast {
        if (!openApiFragmentsDir.exists()) {
            println("No fragments directory at ${openApiFragmentsDir}")
            return@doLast
        }
        val coreFile = openApiFragmentsDir.resolve("core-schemas.yml")
        if (!coreFile.exists()) {
            println("‚ùå Missing core-schemas.yml; aborting assembly")
            return@doLast
        }
        val fragmentFiles =
            openApiFragmentsDir.listFiles { f -> f.isFile && f.name.endsWith(".yml") && f.name != "core-schemas.yml" }
                ?.sortedBy { it.name }.orEmpty()
        val sb = StringBuilder()
        // Header root
        sb.appendLine("openapi: 3.1.0")
        sb.appendLine("info:")
        sb.appendLine("  title: Unified AeGenesis API (Assembled)")
        sb.appendLine("  version: 1.0.0")
        sb.appendLine("  x-assembled-at: ${java.time.Instant.now()}")
        sb.appendLine("servers:")
        sb.appendLine("  - url: https://api.aurafx.com/v1")
        sb.appendLine("paths:")
        fragmentFiles.forEach { frag ->
            val lines = frag.readLines()
            val pathStart = lines.indexOfFirst { it.trimStart().startsWith("/") }
            if (pathStart != -1) {
                lines.drop(pathStart).forEach { line -> sb.appendLine("  $line") }
            }
        }
        // Append components from core
        val coreLines = coreFile.readLines()
        val compStart = coreLines.indexOfFirst { it.trimStart().startsWith("components:") }
        if (compStart != -1) {
            coreLines.drop(compStart).forEach { line -> sb.appendLine(line) }
        } else {
            println("‚ö†Ô∏è core-schemas.yml missing components section")
        }
        val outFile = outputs.files.singleFile
        outFile.parentFile.mkdirs()
        outFile.writeText(sb.toString())
        println("‚úÖ Assembled unified spec -> ${outFile.relativeTo(project.projectDir)}")
    }
}

// OpenAPI Fragment health (standalone)
tasks.register("openApiFragmentHealth") {
    group = "aegenesis"
    description =
        "Analyze OpenAPI fragments for duplicates, missing operationIds, missing security. Use -Dformat=json for JSON output."
    doLast {
        if (!openApiFragmentsDir.exists()) {
            println("No fragment directory present")
            return@doLast
        }
        val fragmentFiles =
            openApiFragmentsDir.listFiles { f -> f.isFile && f.name.endsWith(".yml") && f.name != "core-schemas.yml" }
                ?.sortedBy { it.name }.orEmpty()

        data class OpIssue(val file: String, val path: String, val method: String, val type: String)

        val pathToFiles = mutableMapOf<String, MutableSet<String>>()
        val issues = mutableListOf<OpIssue>()
        fragmentFiles.forEach { file ->
            var currentPath: String? = null
            var currentMethod: String? = null
            var methodHasOperationId = false
            var methodHasSecurity = false
            val lines = file.readLines()
            /**
             * Finalizes processing of the current OpenAPI method.
             *
             * If a path and method are active, appends OpIssue entries for a missing
             * `operationId` and/or missing `security` to the enclosing `issues` collection.
             * Resets the method-level detection flags (`methodHasOperationId` and
             * `methodHasSecurity`) to false.
             */
            fun finalizeMethod() {
                if (currentPath != null && currentMethod != null) {
                    if (!methodHasOperationId) issues += OpIssue(
                        file.name,
                        currentPath!!,
                        currentMethod!!,
                        "MISSING_OPERATION_ID"
                    )
                    if (!methodHasSecurity) issues += OpIssue(
                        file.name,
                        currentPath!!,
                        currentMethod!!,
                        "MISSING_SECURITY"
                    )
                }
                methodHasOperationId = false
                methodHasSecurity = false
            }
            lines.forEach { raw ->
                val line = raw.trimEnd()
                val pathMatch = Regex("^/(?:[A-Za-z0-9._{}\\-]+/?)+:").find(line)
                if (pathMatch != null && !line.startsWith("  ")) {
                    finalizeMethod()
                    currentPath = line.substringBefore(":").trim()
                    pathToFiles.getOrPut(currentPath!!) { mutableSetOf() }.add(file.name)
                    currentMethod = null
                    return@forEach
                }
                val methodMatch =
                    Regex("^\\s{2,}(get|post|put|delete|patch|options|head):\\s*").find(line)
                if (methodMatch != null) {
                    finalizeMethod()
                    currentMethod = methodMatch.groupValues[1].lowercase()
                    return@forEach
                }
                if (currentMethod != null) {
                    if (line.contains("operationId:")) methodHasOperationId = true
                    if (line.trimStart().startsWith("security:")) methodHasSecurity = true
                    if (line.startsWith("  /")) finalizeMethod()
                }
            }
            finalizeMethod()
        }
        val duplicatePaths = pathToFiles.filter { it.value.size > 1 }
        if (jsonFlag) {
            val dupJson = duplicatePaths.entries.joinToString(
                prefix = "{",
                postfix = "}"
            ) { (p, fs) -> "\"$p\":${fs.toList()}" }
            val issuesJson = issues.joinToString(
                prefix = "[",
                postfix = "]"
            ) { i -> "{\"file\":\"${i.file}\",\"path\":\"${i.path}\",\"method\":\"${i.method}\",\"type\":\"${i.type}\"}" }
            println("{" + "\n  \"fragmentCount\": ${fragmentFiles.size},\n  \"pathCount\": ${pathToFiles.size},\n  \"duplicatePaths\": $dupJson,\n  \"operationIssues\": $issuesJson\n}")
        } else {
            println("=== OpenAPI Fragment Health ===")
            println("Fragments: ${fragmentFiles.size}  Paths: ${pathToFiles.size}")
            if (duplicatePaths.isEmpty()) println("‚úÖ No duplicate path definitions") else {
                println("‚ùó Duplicate paths:")
                duplicatePaths.forEach { (p, fs) -> println(" - $p in $fs") }
            }
            val missingOpIds = issues.filter { it.type == "MISSING_OPERATION_ID" }
            val missingSec = issues.filter { it.type == "MISSING_SECURITY" }
            if (missingOpIds.isEmpty()) println("‚úÖ All methods define operationId") else println("‚ùó Missing operationId: ${missingOpIds.size}")
            if (missingSec.isEmpty()) println("‚úÖ All methods define security") else println("‚ùó Missing security: ${missingSec.size}")
        }
    }
}

// CI gating task
tasks.register("openApiEnforce") {
    group = "verification"
    description =
        "Enforce OpenAPI quality: assemble, audit coverage >=95%, no duplicate paths, no missing operationId/security. Fails build on violation."
    dependsOn("openApiAssembleUnified")
    doLast {
        if (!openApiFragmentsDir.exists()) error("Fragments directory missing")
        val assembled =
            layout.buildDirectory.file("openapi/unified-aegenesis-api.generated.yml").get().asFile
        if (!assembled.exists()) error("Assembled spec not found: ${assembled}")
        val lines = assembled.readLines()
        val operationIds = lines.count { it.trimStart().startsWith("operationId:") }
        val verbRegex = Regex("^\\s{2,}(get|post|put|delete|patch|options|head):\\s*")
        val verbs = lines.count { verbRegex.containsMatchIn(it) }
        val coverage = if (verbs == 0) 100.0 else operationIds * 100.0 / verbs
        val fragmentFiles =
            openApiFragmentsDir.listFiles { f -> f.isFile && f.name.endsWith(".yml") && f.name != "core-schemas.yml" }
                ?.toList().orEmpty()

        data class Issue(val kind: String, val detail: String)

        val issues = mutableListOf<Issue>()
        // Re-run fragment health minimal checks
        val pathToFiles = mutableMapOf<String, MutableSet<String>>()
        fragmentFiles.forEach { file ->
            var currentPath: String? = null
            var currentMethod: String? = null
            var hasOpId = false
            var hasSec = false
            val flines = file.readLines()
            /**
             * Finalizes processing for the currently tracked OpenAPI path/method.
             *
             * If both `currentPath` and `currentMethod` are set, records issues when the
             * current operation is missing an `operationId` (`MISSING_OPERATION_ID`) or
             * a `security` declaration (`MISSING_SECURITY`). After evaluation, clears the
             * per-operation flags used for detection (`hasOpId` and `hasSec`).
             *
             * No effect when `currentPath` or `currentMethod` is null.
             */
            fun finalize() {
                if (currentPath != null && currentMethod != null) {
                    if (!hasOpId) issues += Issue(
                        "MISSING_OPERATION_ID",
                        "$currentPath $currentMethod (${file.name})"
                    )
                    if (!hasSec) issues += Issue(
                        "MISSING_SECURITY",
                        "$currentPath $currentMethod (${file.name})"
                    )
                }
                hasOpId = false; hasSec = false
            }
            flines.forEach { raw ->
                val line = raw.trimEnd()
                val pathMatch = Regex("^/(?:[A-Za-z0-9._{}\\-]+/?)+:").find(line)
                if (pathMatch != null && !line.startsWith("  ")) {
                    finalize(); currentPath = line.substringBefore(":").trim(); currentMethod =
                        null; pathToFiles.getOrPut(currentPath!!) { mutableSetOf() }
                        .add(file.name); return@forEach
                }
                val mm = Regex("^\\s{2,}(get|post|put|delete|patch|options|head):\\s*").find(line)
                if (mm != null) {
                    finalize(); currentMethod = mm.groupValues[1]; return@forEach
                }
                if (currentMethod != null) {
                    if (line.contains("operationId:")) hasOpId = true
                    if (line.trimStart().startsWith("security:")) hasSec = true
                }
            }
            finalize()
        }
        pathToFiles.filter { it.value.size > 1 }
            .forEach { (p, fs) -> issues += Issue("DUPLICATE_PATH", "$p -> $fs") }
        if (coverage < 95.0) issues += Issue(
            "LOW_OPERATION_ID_COVERAGE",
            String.format("%.2f%% (<95%%)", coverage)
        )
        if (issues.isNotEmpty()) {
            println("‚ùå OpenAPI enforcement failed:")
            issues.forEach { println(" - [${it.kind}] ${it.detail}") }
            error("OpenAPI quality gate failed with ${issues.size} issue(s).")
        } else {
            println("‚úÖ OpenAPI enforcement passed (operationId coverage=${"""%.2f""".format(coverage)}%, fragments=${fragmentFiles.size}).")
        }
    }
}

// Wire openApiEnforce into check lifecycle (root + subprojects)
if (tasks.findByName("check") == null) {
    tasks.register("check") {
        group = "verification"
        description = "Aggregate verification including OpenAPI enforcement"
        dependsOn("openApiEnforce")
    }
} else {
    tasks.named("check") { dependsOn("openApiEnforce") }
}

gradle.projectsEvaluated {
    val enforce = tasks.named("openApiEnforce")
    rootProject.subprojects.forEach { sp ->
        sp.tasks.findByName("check")?.dependsOn(enforce)
    }
}

// --- Added: Version + Health Split Tasks ---

/**
 * Safely reads all lines from a file path relative to the project.
 *
 * If the file does not exist or an I/O error occurs, returns an empty list instead of throwing.
 *
 * @param path Relative path to the file from the project root.
 * @return The file's lines, or an empty list when the file is missing or cannot be read.
 */
fun Project.safeReadLines(path: String): List<String> = runCatching {
    file(path).takeIf { it.exists() }?.readLines() ?: emptyList()
}.getOrElse { emptyList() }

val toolingHealth = tasks.register("toolingHealth") {
    group = "aegenesis"
    description = "Toolchain / plugin consistency only (no OpenAPI). Use -Dformat=json for JSON."
    doLast {
        val reports = collectModuleReports()
        val expectedJava = "24"
        val expectedKotlin = "24"
        val inconsistentJava =
            reports.filter { it.javaToolchain != null && it.javaToolchain != expectedJava }
                .map { it.name }
        val inconsistentKotlin =
            reports.filter { it.kotlinJvmTarget != null && it.kotlinJvmTarget != expectedKotlin }
                .map { it.name }
        val missingComposeInAndroid =
            reports.filter { it.type.startsWith("android-") && !it.hasCompose }.map { it.name }
        if (jsonFlag) {
            println(
                "{" +
                        "\n  \"modules\": ${reports.size}," +
                        "\n  \"inconsistentJava\": ${inconsistentJava.toJsonArray()}," +
                        "\n  \"inconsistentKotlin\": ${inconsistentKotlin.toJsonArray()}," +
                        "\n  \"missingComposeInAndroid\": ${missingComposeInAndroid.toJsonArray()}\n}"
            )
        } else {
            println("=== Tooling Health ===")
            println("Modules: ${reports.size}")
            println(if (inconsistentJava.isEmpty()) "‚úÖ Java toolchains consistent ($expectedJava)" else "‚ùó Inconsistent Java toolchains: $inconsistentJava")
            println(if (inconsistentKotlin.isEmpty()) "‚úÖ Kotlin JVM targets consistent ($expectedKotlin)" else "‚ùó Inconsistent Kotlin JVM targets: $inconsistentKotlin")
            println(if (missingComposeInAndroid.isEmpty()) "‚úÖ Android Compose enablement consistent" else "‚ö†Ô∏è  Missing Compose: $missingComposeInAndroid")
        }
    }
}

val apiSpecHealth = tasks.register("apiSpecHealth") {
    group = "aegenesis"
    description = "Analyze OpenAPI unified spec health only. Use -Dformat=json for JSON."
    doLast {
        val specFile = file("app/api/unified-aegenesis-api.yml")
        val specExists = specFile.exists()
        val now = Instant.now()
        val specAgeDays =
            if (specExists) Duration.between(Instant.ofEpochMilli(specFile.lastModified()), now)
                .toDays() else -1
        val lines = if (specExists) specFile.readLines() else emptyList()
        val verbRegex = Regex("^\\s{4,}(get|post|put|delete|patch|options|head):\\s*")
        val verbs = lines.count { verbRegex.containsMatchIn(it) }
        val opIds = lines.count { it.trimStart().startsWith("operationId:") }
        val coverage = if (verbs > 0) opIds * 100.0 / verbs else 0.0
        val stale = specAgeDays >= 0 && specAgeDays > 7
        val coverageWarn = coverage < 95.0
        val coverageStr = "%.1f".format(coverage)
        if (jsonFlag) {
            println(
                "{" +
                        "\n  \"specExists\": $specExists," +
                        "\n  \"ageDays\": $specAgeDays," +
                        "\n  \"operations\": $verbs," +
                        "\n  \"operationIds\": $opIds," +
                        "\n  \"operationIdCoveragePct\": $coverageStr," +
                        "\n  \"stale\": $stale," +
                        "\n  \"coverageWarn\": $coverageWarn\n}"
            )
        } else {
            println("=== API Spec Health ===")
            if (!specExists) println("‚ùå unified-aegenesis-api.yml missing") else {
                println("Age days: $specAgeDays")
                println("Operations (verbs): $verbs | operationId: $opIds | coverage: $coverageStr%")
                println(if (stale) "‚ö†Ô∏è  Spec stale (>7 days)" else "‚úÖ Freshness OK")
                println(if (coverageWarn) "‚ö†Ô∏è  operationId coverage <95%" else "‚úÖ Coverage OK")
            }
        }
    }
}

tasks.register("fullHealth") {
    group = "aegenesis"
    description = "Aggregate toolingHealth + apiSpecHealth (prints merged JSON if -Dformat=json)."
    dependsOn(toolingHealth, apiSpecHealth)
    doLast {
        if (jsonFlag) println("(Run tasks individually for structured JSON; aggregation done via dependsOn)") else println(
            "Full health tasks executed (tooling + API spec)."
        )
    }
}

// Version consistency check scanning docs for advertised versions vs catalog
val versionsConsistencyCheck = tasks.register("versionsConsistencyCheck") {
    group = "verification"
    description = "Scan docs for version drift against libs.versions.toml (fails on mismatch)."
    doLast {
        // Extract catalog versions in-memory
        val catalogFile = file("gradle/libs.versions.toml")
        val catalog = catalogFile.readText()
        /**
         * Look up a version value for a given key from the loaded version catalog text.
         *
         * Searches the in-memory `catalog` text (expected to contain the contents of
         * libs.versions.toml) for a line like `key = "1.2.3"` and returns the quoted
         * value if found.
         *
         * @param key The version key as it appears in the TOML (e.g. `kotlin`, `agp`).
         * @return The version string for the key, or `null` if the key is not present.
         */
        fun tomlVersion(key: String): String? = Regex(
            "^$key\\s*=\\s*\"([^\"]+)\"",
            RegexOption.MULTILINE
        ).find(catalog)?.groupValues?.get(1)

        val expected = mapOf(
            "AGP" to (tomlVersion("agp") ?: ""),
            "Kotlin" to (tomlVersion("kotlin") ?: ""),
            "KSP" to (tomlVersion("ksp") ?: ""),
            "ComposeBOM" to (tomlVersion("composeBom") ?: ""),
            "Hilt" to (tomlVersion("hilt-version") ?: ""),
            "YukiHookAPI" to (tomlVersion("yukihookapi") ?: "")
        )
        val docFiles = listOf(
            "BUILD.md", "README.md", "CodeRabbitaiDocs.md", "docs/YUKIHOOK_SETUP_GUIDE.md"
        ).mapNotNull { f -> file(f).takeIf { it.exists() } }
        val mismatches = mutableListOf<String>()
        docFiles.forEach { f ->
            val text = f.readText()
            expected.forEach { (label, ver) ->
                if (ver.isNotBlank()) {
                    // If doc contains label + different version tokens we flag simplest case of wrong phantom version (e.g., 2.1.1)
                    if (label == "YukiHookAPI" && text.contains("YukiHookAPI 2.1.1")) {
                        mismatches += "${f.name}: YukiHookAPI references phantom 2.1.1 (catalog=$ver)"
                    }
                    // Generic drift: look for pattern label + space + version not equal to expected
                    val regex = Regex("$label\\s+([0-9A-Za-z.-]+)")
                    regex.findAll(text).forEach { m ->
                        val found = m.groupValues[1]
                        if (found != ver && !found.contains("phantom", true)) {
                            // Allow multiple references; only record if clearly divergent
                            if (found != "Baseline" && !found.equals(
                                    "alpha",
                                    true
                                )
                            ) mismatches += "${f.name}: $label doc=$found catalog=$ver"
                        }
                    }
                }
            }
        }
        if (jsonFlag) {
            println(mismatches.joinToString(prefix = "[", postfix = "]") { "\"$it\"" })
        } else {
            if (mismatches.isEmpty()) println("‚úÖ Version consistency: no drift detected.") else {
                println("‚ùó Version drift detected (${mismatches.size}):")
                mismatches.forEach { println(" - $it") }
                println("(Run with -Dformat=json for machine output)")
            }
        }
        if (mismatches.isNotEmpty()) error("Version drift detected; update docs or catalog.")
    }
}

// Compose compiler + Kotlin alignment (simple heuristic)
val composeCompilerCheck = tasks.register("composeCompilerCheck") {
    group = "verification"
    description = "Heuristic check that Compose BOM + Kotlin versions are plausible companions."
    doLast {
        val kotlinVer = versionCatalog.findVersion("kotlin").get().toString()
        val composeBom = versionCatalog.findVersion("composeBom").get().toString()
        val notes = mutableListOf<String>()
        if (composeBom.startsWith("2025") && !kotlinVer.startsWith("2.2")) {
            notes += "Compose BOM $composeBom usually expects Kotlin 2.2.x (found $kotlinVer)"
        }
        val stableConfigLines = safeReadLines("compose_compiler_config.conf").filter {
            it.isNotBlank() && !it.trimStart().startsWith("#")
        }
        if (jsonFlag) {
            println(
                "{" +
                        "\n  \"kotlin\": \"$kotlinVer\"," +
                        "\n  \"composeBom\": \"$composeBom\"," +
                        "\n  \"stabilityClassesCount\": ${stableConfigLines.size}," +
                        "\n  \"warnings\": ${notes.toJsonArray()}\n}"
            )
        } else {
            println("=== Compose Compiler Check ===")
            println("Kotlin=$kotlinVer | Compose BOM=$composeBom | stability classes=${stableConfigLines.size}")
            if (notes.isEmpty()) println("‚úÖ Alignment heuristic OK") else notes.forEach { println("‚ö†Ô∏è  $it") }
        }
    }
}

// Doctor stack aggregates multiple checks without failing early
tasks.register("doctorStack") {
    group = "aegenesis"
    description =
        "Aggregate high-level stack diagnostics (toolingHealth, apiSpecHealth, composeCompilerCheck)."
    dependsOn(toolingHealth, apiSpecHealth, composeCompilerCheck)
    doLast { println("Doctor stack completed.") }
}

// Apply auxiliary cleanup script
apply(from = "nuclear-clean.gradle.kts")

// Enforce google-services only on application / dynamic-feature modules
subprojects {
    pluginManager.withPlugin("com.google.gms.google-services") {
        val isApp =
            pluginManager.hasPlugin("com.android.application") || pluginManager.hasPlugin("com.android.dynamic-feature")
        if (!isApp) {
            throw GradleException("google-services plugin misapplied in $path (must be only in application or dynamic-feature module)")
        }
    }
}

// Aggregate deep clean (includes nuclearClean if present)
if (tasks.findByName("nuclearClean") != null) {
    tasks.register("deepClean") {
        group = "consciousness"
        description =
            "Run nuclearClean plus standard clean and refresh dependencies suggestion output"
        dependsOn("nuclearClean")
        doLast {
            println("Deep clean completed. Recommended fresh build: ./gradlew build --refresh-dependencies")
        }
    }
}

// --- Documentation (Dokka) Aggregation ---
subprojects {
    // plugins.withId("org.jetbrains.kotlin.android") { apply(plugin = "org.jetbrains.dokka") } // Dokka application commented out
    // plugins.withId("org.jetbrains.kotlin.jvm") { apply(plugin = "org.jetbrains.dokka") } // Dokka application commented out
}

// Aggregate all dokkaHtml outputs into build/aggregated-dokka
val apiDocs = tasks.register("apiDocs") {
    group = "documentation"
    description = "Generate aggregated Dokka HTML docs for all Kotlin modules"
    // Collect dokkaHtml tasks if present
    val dokkaTasks = subprojects.mapNotNull { sp -> sp.tasks.findByName("dokkaHtml") }
    dependsOn(dokkaTasks)
    doLast {
        val targetDir = layout.buildDirectory.dir("aggregated-dokka").get().asFile
        targetDir.deleteRecursively(); targetDir.mkdirs()
        subprojects.forEach { sp ->
            val outDir = File(layout.buildDirectory.dir("dokka/html").get().asFile, "dokka/html")
            if (outDir.exists()) {
                val dest = File(targetDir, sp.name)
                outDir.copyRecursively(dest, overwrite = true)
            }
        }
        println("Aggregated API docs -> ${targetDir}")
        println("(Run: open ${targetDir}/index.html or browse module subfolders)")
    }
}

// Zip aggregated docs for distribution
tasks.register<Zip>("apiDocsZip") {
    group = "documentation"
    description = "Package aggregated API docs into a zip archive"
    dependsOn(apiDocs)
    archiveFileName.set("memoriaos-api-docs.zip")
    destinationDirectory.set(layout.buildDirectory.dir("distributions"))
    from(layout.buildDirectory.dir("aggregated-dokka"))
}

// Apply dependency resolution fix
apply(from = "dependency-fix.gradle.kts")


